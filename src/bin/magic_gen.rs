use std::io::Write;
use std::{fs::File, io::BufWriter, path::Path};

use eschec::Square;
use eschec::{BitBoard, Piece, moves::precomputed::MOVE_TABLES, utils::prng::Prng};
use miette::IntoDiagnostic;
#[cfg(feature = "rayon")]
use rayon::iter::{IntoParallelIterator, ParallelIterator};
use tracing::info;

/// A generator for finding magic numbers for sliding piece attack generation
#[derive(Clone)]
struct MagicGenerator {
    /// For a given square, all possible blocker config
    occupancies: Vec<BitBoard>,
    /// For each occupancy, the correct attack set
    attack_sets: Vec<BitBoard>,
    /// A temporaty table used for testing magic number candidates
    used_attacks: Vec<Option<BitBoard>>,
    /// Pseudo random number generator
    prng: Prng,
}

impl MagicGenerator {
    fn new(seed: u64) -> Self {
        Self {
            occupancies: Vec::with_capacity(4096), // 2^12, max bits for a rook mask
            attack_sets: Vec::with_capacity(4096),
            used_attacks: Vec::with_capacity(4096),
            prng: Prng::init(seed),
        }
    }

    fn generate_occupancies(&mut self, mask: BitBoard) {
        self.occupancies.clear();
        let mut bb = BitBoard(0);
        loop {
            self.occupancies.push(bb);
            bb = BitBoard((bb.0.wrapping_sub(mask.0)) & mask.0);
            if bb.0 == 0 {
                break;
            }
        }
    }

    fn generate_attack_set(&self, piece: Piece, sq: usize, blockers: BitBoard) -> BitBoard {
        match piece {
            Piece::Rook => MOVE_TABLES.get_rook_moves(sq, BitBoard(0), blockers),
            Piece::Bishop => MOVE_TABLES.get_bishop_moves(sq, BitBoard(0), blockers),
            _ => unreachable!(),
        }
    }

    fn find_magic(&mut self, piece: Piece, sq: usize) -> (u64, u8, BitBoard) {
        let square = Square::new(sq).unwrap();
        info!("{piece}, {square}");
        let mask = match piece {
            Piece::Rook => MOVE_TABLES.generate_sliding_attack_mask(sq, true),
            Piece::Bishop => MOVE_TABLES.generate_sliding_attack_mask(sq, false),
            _ => unreachable!(),
        };

        let num_mask_bits = mask.pop_count();
        let shift = 64 - num_mask_bits;

        self.generate_occupancies(mask);
        self.attack_sets.clear();
        for &occupancy in &self.occupancies {
            self.attack_sets
                .push(self.generate_attack_set(piece, sq, occupancy));
        }

        let table_size = 1 << num_mask_bits;
        self.used_attacks.clear();
        self.used_attacks.resize(table_size, None);

        let mut counts = 0;
        for i in 0..500_000_000 {
            counts = i;
            if i % 100_000 == 0 {
                info!("Here in {piece} {square}, skipped: {counts}: {i}");
            }
            let magic_candidate = self.prng.sparse_rand();
            if (mask.0.wrapping_mul(magic_candidate) & 0xFF00000000000000) < 6 {
                continue;
            }
            self.used_attacks.iter_mut().for_each(|x| *x = None);
            let mut fail = false;
            for i in 0..self.occupancies.len() {
                let hash = self.occupancies[i].0.wrapping_mul(magic_candidate);
                let index = (hash >> shift) as usize;
                if self.used_attacks[index].is_none() {
                    self.used_attacks[index] = Some(self.attack_sets[i]);
                } else if self.used_attacks[index] != Some(self.attack_sets[i]) {
                    fail = true;
                    break;
                }
            }
            if !fail {
                return (magic_candidate, shift as u8, mask);
            }
        }
        panic!("Failed to find magic number for {piece} on square {sq}, skipped: {counts}");
    }
}

fn main() -> miette::Result<()> {
    eschec::init();
    println!("Generating magic bitboard constants ... (This may take some time)");

    #[cfg(not(feature = "rayon"))]
    let mut generator = MagicGenerator::new(0xDEAD_BEEF_DEAF_CAFE);

    let out_dir = env!("CARGO_MANIFEST_DIR");
    let dest_path = Path::new(&out_dir).join("src/moves/magic_constants.rs");
    let mut f = BufWriter::new(File::create(&dest_path).unwrap());

    writeln!(f, "// Generated by MagicGenerator (src/bin/magic-gen.rs)").into_diagnostic()?;
    writeln!(f, "// DO NOT EDIT\n").into_diagnostic()?;

    #[cfg(feature = "rayon")]
    let rook_results: Vec<_> = (0..64)
        .into_par_iter()
        .map(|sq| {
            let mut generator = MagicGenerator::new(0xDEAD_BEEF_DEAF_CAFE + sq as u64);
            let (magic, shift, mask) = generator.find_magic(Piece::Rook, sq);

            let num_attacks_sets = 1 << (64 - shift);
            let mut attacks_for_sq = vec![BitBoard(0); num_attacks_sets];

            generator.generate_occupancies(mask);
            for occupancy in &generator.occupancies {
                let attack = generator.generate_attack_set(Piece::Rook, sq, *occupancy);
                let index = (occupancy.0.wrapping_mul(magic) >> shift) as usize;
                attacks_for_sq[index] = attack;
            }
            println!("Found rook magic for square {sq}");
            (sq, magic, shift, mask.0, attacks_for_sq)
        })
        .collect();

    // Rooks
    let mut rook_magics = [0u64; 64];
    let mut rook_masks = [0u64; 64];
    let mut rook_shifts = [0u8; 64];
    let mut rook_attacks_table = Vec::new();
    let mut rook_offsets = [0usize; 64];

    #[cfg(feature = "rayon")]
    for (sq, magic, shift, mask, attacks_for_sq) in rook_results {
        rook_magics[sq] = magic;
        rook_masks[sq] = mask;
        rook_shifts[sq] = shift;
        rook_offsets[sq] = rook_attacks_table.len();
        rook_attacks_table.extend(attacks_for_sq);
    }
    #[cfg(not(feature = "rayon"))]
    for sq in 0..64 {
        let (magic, shift, mask) = generator.find_magic(Piece::Rook, sq);
        info!("{magic}, {shift}, {}", mask.print_bitboard());
        rook_magics[sq] = magic;
        rook_shifts[sq] = shift;
        rook_masks[sq] = mask.0;
        rook_offsets[sq] = rook_attacks_table.len();

        let num_attacks_sets = 1 << (64 - shift);
        let mut attakcs_for_sq = vec![BitBoard(0); num_attacks_sets];

        generator.generate_occupancies(BitBoard(rook_masks[sq]));
        for occupancy in &generator.occupancies {
            let attack = generator.generate_attack_set(Piece::Rook, sq, *occupancy);
            let index = (occupancy.0.wrapping_mul(magic) >> shift) as usize;
            attakcs_for_sq[index] = attack;
        }
        rook_attacks_table.extend(attakcs_for_sq);
        println!("Found rook magic for squares {sq}");
    }

    writeln!(f, "pub const ROOK_MASKS: [u64; 64] = {rook_masks:?};").unwrap();
    writeln!(f, "pub const ROOK_MAGICS: [u64; 64] = {rook_magics:?};").unwrap();
    writeln!(f, "pub const ROOK_SHIFTS: [u8; 64] = {rook_shifts:?};").unwrap();
    writeln!(
        f,
        "pub const ROOK_ATTACK_OFFSETS: [usize; 64] = {rook_offsets:?};"
    )
    .unwrap();
    writeln!(
        f,
        "pub const ROOK_ATTACKS: [BitBoard; {}] = {:?};",
        rook_attacks_table.len(),
        rook_attacks_table
    )
    .unwrap();

    // --- BISHOPS ---

    info!("Generating Bishop magics...");
    #[cfg(feature = "rayon")]
    let bishop_results: Vec<_> = (0..64)
        .into_par_iter() // <-- Rayon again
        .map(|sq| {
            let mut generator = MagicGenerator::new(0xCAFE_BABE_BEEF_DEAD + sq as u64);
            let (magic, shift, mask) = generator.find_magic(Piece::Bishop, sq);

            let num_attack_sets = 1 << (64 - shift);
            let mut attacks_for_sq = vec![BitBoard(0); num_attack_sets];

            generator.generate_occupancies(mask);
            for occupancy in &generator.occupancies {
                let attack = generator.generate_attack_set(Piece::Bishop, sq, *occupancy);
                let index = (occupancy.0.wrapping_mul(magic) >> shift) as usize;
                attacks_for_sq[index] = attack;
            }
            println!("Found bishop magic for square {sq}");
            (sq, magic, shift, mask.0, attacks_for_sq)
        })
        .collect();
    let mut bishop_magics = [0u64; 64];
    let mut bishop_masks = [0u64; 64];
    let mut bishop_shifts = [0u8; 64];
    let mut bishop_attacks_table = Vec::new();
    let mut bishop_offsets = [0usize; 64];

    #[cfg(feature = "rayon")]
    for (sq, magic, shift, mask, attacks_for_sq) in bishop_results {
        bishop_magics[sq] = magic;
        bishop_masks[sq] = mask;
        bishop_shifts[sq] = shift;
        bishop_offsets[sq] = bishop_attacks_table.len();
        bishop_attacks_table.extend(attacks_for_sq);
    }
    #[cfg(not(feature = "rayon"))]
    for sq in 0..64 {
        let (magic, shift, mask) = generator.find_magic(Piece::Bishop, sq);
        bishop_magics[sq] = magic;
        bishop_shifts[sq] = shift;
        bishop_masks[sq] = mask.0;
        bishop_offsets[sq] = bishop_attacks_table.len();
        let num_attack_sets = 1 << (64 - shift);
        let mut attacks_for_sq = vec![BitBoard(0); num_attack_sets];

        generator.generate_occupancies(BitBoard(bishop_masks[sq]));
        for occupancy in &generator.occupancies {
            let attack = generator.generate_attack_set(Piece::Bishop, sq, *occupancy);
            let index = (occupancy.0.wrapping_mul(magic) >> shift) as usize;
            attacks_for_sq[index] = attack;
        }
        bishop_attacks_table.extend(attacks_for_sq);
        println!("Found bishop magic for square {sq}");
    }

    writeln!(f, "\npub const BISHOP_MASKS: [u64; 64] = {bishop_masks:?};").unwrap();
    writeln!(f, "pub const BISHOP_MAGICS: [u64; 64] = {bishop_magics:?};").unwrap();
    writeln!(f, "pub const BISHOP_SHIFTS: [u8; 64] = {bishop_shifts:?};").unwrap();
    writeln!(
        f,
        "pub const BISHOP_ATTACK_OFFSETS: [usize; 64] = {bishop_offsets:?};"
    )
    .unwrap();
    writeln!(
        f,
        "pub const BISHOP_ATTACKS: [BitBoard; {}] = {:?};",
        bishop_attacks_table.len(),
        bishop_attacks_table
    )
    .unwrap();

    println!("\nSuccessfully generated and wrote src/moves/magic_constants.rs");
    Ok(())
}
